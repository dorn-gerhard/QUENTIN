function Q = coteda(f,a,b,tol,trace,varargin)
%   COTEDA  Numerically evaluates an integral using adaptively
%   a Newton-Cotes 5 point rule and at the same time is double adaptive
%   allowing to use a 9 point Newton-Cotes rule before it may
%   decide to subdivide the interval.
%
%   Q=COTEDA('F',A,B) approximates the integral of F(X) from
%   A to B to a relative precision TOL= 10^-3.  'F' is a
%   string containing the name of the function. The
%   function F must return a vector of output values if
%   given a vector of input values.
%
%   Q=COTEDA('F',A,B,TOL) integrates to a relative
%   precision of TOL.
%
%   Q=COTEDA('F',A,B,TOL,TRACE) displays the left
%   end point of the current interval, the interval
%   length, the partial integral and the rule used (5 or 9 ).
%
%   Q=COTEDA('F',A,B,TOL,TRACE,P1,P2,...) allows
%   coefficients P1, ... to be passed directly to the
%   function F:  G=F(X,P1,P2,...). To use default values
%   for TOL or TRACE, one may pass the empty matrix ([]).
%
%   Terje O. Espelid 20/02/02
%   Reference   Berntsen and Espelid, TOMS 1991
%               Espelid, in Espelid and Genz (eds.), Kluwer 1992.
%               Espelid, Tech report May 2002.

global termination2 p2 w2 nw2

  termination2 = 0;
  if(nargin<4), tol=[]; end;
  if(nargin<5), trace=[]; end;
  if(isempty(tol)), tol=10^-3; end;
  if(isempty(trace)), trace=0; end;
%   9 points Cotes rule in the interval [-1,1];
  p2=[-4,-3, -2,-1,0,1,2,3,4]/4;
%   The Cotes weights:
  w2=[989,5888,-928,10496,-4540,10496,-928,5888,989]/14175;
%   Eight Orthogonal Nullrules of degree  7,6,5,4,3,2,1,0 are given.
%   All odd numbered are symmetric.
%   All even numbered are antisymmetric.
%   We give the first five elements for each nullrule.
  nulw=[0.1101854769234527D-01,-0.8814838153876216D-01,...
        0.3085193353856676,-0.6170386707713351, 0.7712983384641688;
        0.4267465171184540D-01,-0.2560479102710724,...
        0.5974451239658356, -0.5974451239658356,0;
        0.1123675793894425,-0.4775622124051307,0.6180216866419335,...
        0.2809189484736109D-01,-0.5618378969472148;
        0.2311270062743306,-0.6355992672544093 ,0.2311270062743311,...
        0.5200357641172426,0;
        0.3911196434508170,-0.5866794651762256,-0.3073082912827879,...
        0.2514340565041003,0.5028681130081833;
        0.5561911416025476,-0.2780955708012750,-0.5164632029166498,...
       -0.3575514481730693,0;
        0.6647755647017197,0.1661938911754310,-0.1899358756290700,...
       -0.4036137357117497,-0.4748396890726778;
        0.6455025992424890,0.4841269494318643,0.3227512996212468,...
        0.1613756498106190,0];
%   Then we use the symmetry and finally the antisymmetry
  nw2=[nulw(1:8,1:5),nulw(1:8,4:-1:1)];
  nw2(2:2:8,6:9)=-nw2(2:2:8,6:9);
%   Apply the 9 point rule to get an initial estimate.
  h=(b-a)/2;c=(b+a)/2;x=c+h*p2; y=feval(f,x,varargin{:});
  is=h*w2*y';isabs=h*abs(w2)*abs(y');
  noise=50*eps*isabs;
  if(abs(is) <= noise), is=b-a, end;
  tol=max(tol,noise/abs(is));
  e=h*nw2*y';e2=e.^2;E2= (e2(1:2:7)+e2(2:2:8));
  E=sqrt(E2);Emin=min(E(2:4));
  if Emin==0,
     rmax=2;
  else
     r=E(1:3)./E(2:4);
     if sum(isinf(r))>0
        rmax=2;
     else
        rmax=max(r);
     end
  end
  if rmax > 1
     err=50*max(E);
  elseif 0.25 < rmax
     err=50*rmax*E(1);
  else
     err=50*sqrt(4*rmax)*rmax*E(1);
  end
  if (E(1)<noise) & (E(2) < noise), err=0; end
  if (err<=tol*abs(is)) | (x(2)<=a) | (b<=x(8)),
     if ((x(2) <= a) | (b<=x(8))) & (termination2==0);
        warning(['Interval too small: required tolerance may not be met.']);
        termination2 =1;
     end
     Q=is;
     if(trace), disp( [a 2*h Q 9] ), end
  else
     Q=coter(f,a,c,y(1:5),is,tol,trace,varargin{:})+ ...
     coter(f,c,b,y(5:9),is,tol,trace,varargin{:});
  end

function Q = coter(f,a,b,y,is,tol,trace,varargin)
%   COTER Recursive function used by coteda.
%   Q = COTER('F',A,B,FA,FC,FB,IS,TOL,TRACE) tries to
%   approximate the integral of F(X) from A to B to
%   an appropriate relative error. The argument 'F' is
%   a string containing the name of f.  The remaining
%   arguments are generated by COTEDA or by recursion.

global termination2 p2 w2 nw2

%   The five point Cotes rule in the interval [-1,1];
  p1=[-1,-.5, 0,.5,1];
%   The Cotes weights:
  w1=[7,32,12,32,7]/45;
%   Nullrules: 4 nullrules of degrees 3,2,1 and 0
%   for the 5 point Cotes rule.
  nw1=[0.1271031188518578,-0.5084124754074312,0.7626187131111468,...
      -0.5084124754074312,0.1271031188518578;
         0.3362832433427012,-0.6725664866854024,0,0.6725664866854024,...
        -0.3362832433427012;
         0.5684224278099782,-0.2842112139049893,-0.5684224278099774,...
        -0.2842112139049893,0.5684224278099782;
         0.6725664866854023,0.3362832433427017,0,-0.3362832433427017,...
        -0.6725664866854023];
  h=(b-a)/2; c=(a+b)/2;x=c+p1*h;

%   First we try the 5 point rule

  i=h*w1*y';E=abs(h*nw1*y');Emin=min(E(2:4));iabs=h*w1*abs(y');noise=50*iabs*eps;
  if Emin==0,
     rmax=2;
  else
     r=E(1:3)./E(2:4);
     if sum(isinf(r))>0
        rmax=2;
     else
        rmax=max(r);
     end
  end
  C=32;
  if rmax > 1
     err=C*max(E);
  elseif 0.5 < rmax
     err=C*rmax*E(2);
  else
    err=C*(2*rmax)^2*rmax*E(2);
  end
  if (E(1)<noise) & (E(2) < noise), err=0; end

  if (err<=max(tol*abs(is),noise)) | (x(2)<=a) | (b<=x(4)),
     if ((x(2) <= a) | (b<=x(4))) & (termination2==0);
         warning(['Interval too small: required tolerance may not be met.']);
         termination2 =1;
     end
     Q=i;
     if(trace), disp( [ a 2*h Q 5 ] ), end
  else
%   Next we try the 9 point rule
     z=c+[-3,-1,1,3]*h/4;fz=feval(f,z,varargin{:});
     y=[y(1),fz(1),y(2),fz(2),y(3),fz(3),y(4),fz(4),y(5)];
     i=h*w2*y';iabs=h*abs(w2)*abs(y');noise=50*iabs*eps;
     e=h*nw2*y';e2=e.^2;E2= (e2(1:2:7)+e2(2:2:8));
     E=sqrt(E2);Emin=min(E(2:4));
     if Emin==0,
        rmax=2;
     else
        r=E(1:3)./E(2:4);
        if sum(isinf(r))>0
           rmax=2;
        else
           rmax=max(r);
        end
     end
     D=128;
     if rmax > 1
        err=D*max(E);
     elseif 0.25 < rmax
         err=D*rmax*E(1);
     else
         err=D*sqrt(4*rmax)*rmax*E(1);
     end
     if (E(1)<noise) & (E(2) < noise), err=0; end;
     if (err<=max(tol*abs(is),noise)) | (z(1)<=a) | (b<=z(4)),
         if ((z(1) <= a) | (b<=z(4))) & (termination2==0);
            warning(['Interval too small: required tolerance may not be met.']);
            termination2 =1;
         end
         Q=i;
         if(trace), disp( [ a 2*h Q 9] ), end;
     else
         Q=coter(f,a,c,y(1:5),is,tol,trace,varargin{:})+ ...
         coter(f,c,b,y(5:9),is,tol,trace,varargin{:});
     end
  end
